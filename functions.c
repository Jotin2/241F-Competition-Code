#pragma config(Sensor, in7,    gyro,           sensorGyro)
#pragma config(Sensor, in8,    accel,          sensorAccelerometer)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_mm)
#pragma config(Sensor, dgtl4,  tIntake2,       sensorTouch)
#pragma config(Sensor, dgtl5,  tLaunch,        sensorTouch)
#pragma config(Sensor, dgtl6,  pn1,            sensorDigitalOut)
#pragma config(Sensor, dgtl7,  sonar2,         sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  sonarBL,        sensorSONAR_mm)
#pragma config(Sensor, dgtl11, sonarBR,        sensorSONAR_mm)
#pragma config(Motor,  port1,           intake1,       tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           RF,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           RB,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           LF,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           LB,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           flywheel1,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           launcher1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           launcher2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           flywheel2,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          intake2,       tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* @file functions.c
* @brief This file contains all functions to be used by
* the competition code.
*
* @warning DO NOT compile this file
* by itself, it will not work. Instead, save it
* and compile main.c
*
* Also, you must include your motor and sensor setup somewhere in this file.
*
* @author	 Sean Kelley      sgtkode01@gmail.com
* @author   Bernard Suwirjo  bsuwirjo@gmail.com
*
*/

// GLOBAL VARIABLES
int flywheel = 0;
int bInIntake1 = 0;
int bInIntake2 = 0;
bool bInLauncher = false;
int leftButton = 1;
int centerButton = 2;
int rightButton = 4;
int isMain = 1;
int isBattery = 0;
int isAutonomous = 0;
string mainbattery;
void back(int a, int b,int c);



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Table of Contents
//
//			Function Name              Arguments  *x is defualt for motor speed
//
// 			drive()--------------------bool half
//			clearMotor()---------------None
//			motorcheck()---------------None
//			forwardSeconds()-----------float s, float x=118
//			backwardSeconds()----------float s, float x=118
//			turnRightDegrees()---------float degree, float x=90
//			turnLeftDegrees()----------float degree, float x=90
//			turnRightSeconds()---------float seconds, float x=118
//			turnLeftSeconds()----------float seconds, float x=118
//			runLauncher()--------------int rotations, int speed
//			runIntake()----------------float seconds
//			clearLine()----------------None
//      battery()------------------None
//      testLCD()------------------None
//      mainLCD()------------------None
//
/////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 DRIVETRAIN
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
* Gives drive control to VexNET controller
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @param  half  determines if motors should be running at half speed
*/
void drive(bool half=false)
{
	if (half==false)//Check if drive toggles half speed.
	{
		motor[LF] = vexRT[Ch2]; //give drive direct control.
		motor[LB] = vexRT[Ch2];
		motor[RF] = vexRT[Ch3];
		motor[RB] = vexRT[Ch3];
	}
	else if(half ==true)
	{
		motor[LF] = vexRT[Ch3]/3;//give drive control but all motor maxes are a third of their orignal max.
		motor[LB] = vexRT[Ch3]/3;
		motor[RF] = vexRT[Ch2]/3;
		motor[RB] = vexRT[Ch2]/3;
	}
}

/**
* Moves forward depending on the value saved on the ultrasonic sensor
*
* @author Joshua Asari josh.asari@gmail.com
*
* @params  BL  Back left ultrasonic value
*	@params	 BR  Back right ultrasonic value
*	@params	 x   Drive motor value
*
*/
void forwardWall(int BL, int BR, int x = 35)
	{
		if((SensorValue[sonarBR] + SensorValue[sonarBL])/2 < (BL + BR)/2 )
			{
			while((SensorValue[sonarBR] + SensorValue[sonarBL])/2 < (BL + BR)/2 )
				{
					motor[RB]=-x;
					motor[RF]=-x;
					motor[LF]=-x;
					motor[LB]=-x;
				}
				motor[RB]=15;
				motor[RF]=15;
				motor[LF]=15;
				motor[LB]=15;
				wait1Msec(100);
				motor[RB]=0;
				motor[RF]=0;
				motor[LF]=0;
				motor[LB]=0;
			}
			else if((SensorValue[sonarBR] + SensorValue[sonarBL])/2 > (BL + BR)/2 )
			{
			while((SensorValue[sonarBR] + SensorValue[sonarBL])/2 > (BL + BR)/2 )
				{
					motor[RB]=x;
					motor[RF]=x;
					motor[LF]=x;
					motor[LB]=x;
				}
				motor[RB]=-15;
				motor[RF]=-15;
				motor[LF]=-15;
				motor[LB]=-15;
				wait1Msec(100);
				motor[RB]=0;
				motor[RF]=0;
				motor[LF]=0;
				motor[LB]=0;
			}
	}
//test
/**
* Checks if the robot is perpendicular to a wall
*
* @author Joshua Asari josh.asari@gmail.com
*
* @params  z   True or false
*	@params	 x   x is the value of BR ultra sonic
*	@params	 y   y is the value of BL ultra sonic
*
*/
void checkPerp(int z = 1, int x = 0, int y = 0)
{
	int backloop = 0;
	if(z == 1)
	{
		if( SensorValue[sonarBR] != SensorValue[sonarBL])
		{
			if(SensorValue[sonarBR] > SensorValue[sonarBL])
			{
				while(SensorValue[sonarBR]> SensorValue[sonarBL])
				{
					motor[RF] = 45;
					motor[RB] = 45;
					motor[LF] = -45;
					motor[LB] = -45;
					backloop++;
					if(backloop >= 100)
					{
						break;
					}
				}
	  		motor[RF] = -45;
				motor[RB] = -45;
				motor[LF] = 45;
				motor[LB] = 45;
				wait1Msec(100);
				motor[RF] = 0;
				motor[RB] = 0;
				motor[LF] = 0;
				motor[LB] = 0;
			}
			else if(SensorValue[sonarBL] > SensorValue[sonarBR])
			{
				while(SensorValue[sonarBL]  > SensorValue[sonarBR] )
				{
					motor[RF] = -45;
					motor[RB] = -45;
					motor[LF] = 45;
					motor[LB] = 45;
					backloop++;
					if(backloop >= 100)
					{
						break;
					}
				}
				motor[RF] = 45;
				motor[RB] = 45;
				motor[LF] = -45;
				motor[LB] = -45;
				wait1Msec(100);
				motor[RF] = 0;
				motor[RB] = 0;
				motor[LF] = 0;
				motor[LB] = 0;
			}
		}
	}
	else
	{

		int dif = y-x;
		if(SensorValue[sonarBL] - SensorValue[sonarBR] > -dif)
		{
			while(SensorValue[sonarBL] - SensorValue[sonarBR] > -dif)
			{
						motor[RF] = -45;
						motor[RB] = -45;
						motor[LF] = 45;
						motor[LB] = 45;
			}
					motor[RF] = 30;
					motor[RB] = 30;
					motor[LF] = -30;
					motor[LB] = -30;
					wait1Msec(100);
					motor[RF] = 0;
					motor[RB] = 0;
					motor[LF] = 0;
					motor[LB] = 0;
		}
			else
		{
			while(SensorValue[sonarBL] - SensorValue[sonarBR] < -dif)
			{
						motor[RF] = 45;
						motor[RB] = 45;
						motor[LF] = -45;
						motor[LB] = -45;
			}
					motor[RF] = -30;
					motor[RB] = -30;
					motor[LF] = 30;
					motor[LB] = 30;
					wait1Msec(100);
					motor[RF] = 0;
					motor[RB] = 0;
					motor[LF] = 0;
					motor[LB] = 0;
		}
	}

}

/**
* Clears all the motors
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*/
void clearMotor()
{
	//Set all motor values to 0
	motor[LF] = 0;
	motor[LB] = 0;
	motor[RF] = 0;
	motor[RB] = 0;
}

/**
* Moves forward util a wall is sensed and a certain ultra sonic value is reached
*
* @author Joshua Asari josh.asari@gmail.com
*
* @params  d   Distance away from the wall until the robot stops
*	@params	 x   Drive motor value
*
*/
void forwardsonic(float d,float x=118)
{
	while(SensorValue[sonar2] > 50  )
		{
			motor[RB]=-x;
			motor[RF]=-x;
			motor[LF]=-x;
			motor[LB]=-x;
		}
 	while(SensorValue[sonar2] > d  )
		{
			motor[RB]=-45;
			motor[RF]=-45;
			motor[LF]=-45;
			motor[LB]=-45;
		}
	motor[RB]=5;
	motor[RF]=5;
	motor[LF]=5;
	motor[LB]=5;
	wait1Msec(100);
	motor[RB]=0;
	motor[RF]=0;
	motor[LF]=0;
	motor[LB]=0;
}

/**
* Moves bot forward for a given amount of seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @params  s  amount of seconds to move forward
*	@params  x  speed of motors
*
*/
void forwardSeconds(float s,float x=118)
{
	//Set all motors to target value
	motor[RB]=-x;
	motor[RF]=-x;
	motor[LF]=-x;
	motor[LB]=-x;
	wait1Msec(s*1000);//Wait given amount of time
	motor[RB]=5;
	motor[RF]=5;
	motor[LF]=5;
	motor[LB]=5;
	wait10Msec(10);
	motor[RB]=0;
	motor[RF]=0;
	motor[LF]=0;
	motor[LB]=0;
}

/*
* Moves bot backward for a given amount of seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @params  s  amount of seconds to move backward
*	@params  x  speed of motors
*
*/
void backwardSeconds(float s, float x=118)
{
	//Set all motors to negative target value
	motor[LF]=-x;
	motor[RF]=-x;
	motor[LB]=-x;
	motor[RF]=-x;
	wait1Msec(s*1000);//Wait given amount of time
	motor[LF]=0;
	motor[RF]=0;
	motor[LB]=0;
	motor[RF]=0;
}

/**
* Turns bot right a given amount of degrees
*
* @warning requires gyro
* @author Bernard Suwirjo  bsuwirjo@gmail.com
* @author Sean Kelley  sgtkode01@gmail.com
*
* @params  degree  amount of degrees to turn right
*	@params	 x       speed of motors
*
*/
void turnRightDegrees(float degree, float x=90)
{
	//Reset gyro
	SensorValue[gyro]=0;
	//gyro takes degrees from 0-3600, so we multiply by 10 to get a gyro processable number
	degree=degree*10 + 28;
	//We want to slow down when we approach the target, so we calculate a first turn segment as 60% of the total
	float first=degree*.35;
	while(abs(SensorValue[gyro]) < first) //Turn the first 60%
	{
	//Since it's turn right, we want to set right motors backwards and left motors forward.
	motor[LF] = x;
	motor[RF] = -x;
	motor[LB] = x;
	motor[RB] = -x;
	}
	while(abs(SensorValue[gyro]) <degree) //Turn the remainin amount.
	{
	//We don't want the motors to run too slow, so we set a a safety net. The motor can't have a power less than 40.
	if(x*.35<40)//If 35% of the motor power is less than 40, set the power to 40.
	{
	motor[LF] = 64;
	motor[RF] = -64;
	motor[LB] = 64;
	motor[RB] = -64;
	}
	else //If not set it to 35%
	{
	motor[LF] = x*.35;
	motor[RF] = -x*.35;
	motor[LB] = x*.35;
	motor[RB] = -x*.35;
	}
	}
	clearMotor();
}

/**
* Turns bot left a given amount of degrees
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
* @author Sean Kelley  sgtkode01@gmail.com
*
* @params  degree  amount of degrees to turn left
*	@params	 x       speed of motors
*
*/

void turnLeftDegrees(float degree, float x=90)
{
	//Reset gyro
	SensorValue[gyro]=0;
	//gyro takes degrees from 0-3600, so we multiply by 10 to get a gyro processable number
	degree=degree*10 + 28;
	//We want to slow down when we approach the target, so we calculate a first turn segment as 60% of the total
	float first=degree*.45;
	while(abs(SensorValue[gyro]) < first)
	{
	//Since it's turn left, we want to set right motors forwards and left motors backwards.
	motor[LF] = -x;
	motor[RF] = x;
	motor[LB] = -x;
	motor[RB] = x;
	}
	while(abs(SensorValue[gyro]) < degree)
	{
	//We don't want the motors to run too slow, so we set a a safety net. The motor can't have a power less than 40.
	if(x*.35<40)//If 35% of the motor power is less than 40, set the power to 40.
	{
	motor[LF] = -58;
	motor[RF] = 58;
	motor[LB] = -58;
	motor[RB] = 58;
	}
	else //If not set it to 35%
	{
	motor[LF] = -x*.35;
	motor[RF] = x*.35;
	motor[LB] = -x*.35;
	motor[RB] = x*.35;
	}
	}
	clearMotor();
}


/**
* Turns bot right a given amount of seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @params  seconds   amount of seconds to turn right
* @params	 x         speed of motors
*
*/
void turnRightSeconds(float seconds, float x=45)
{
	//Since turn right, we want to set left motors forwards and right motors backwards.
	motor[LF]=-x;
	motor[LB]=-x;
	motor[RF]=x;
	motor[RB]=x;
	wait1Msec(seconds*1000); //Wait desired amount of time
		motor[LF]=-10;
	motor[LB]=-10;
	motor[RF]=10;
	motor[RB]=10;
	wait10Msec(10);
			motor[LF]=0;
	motor[LB]=0;
	motor[RF]=0;
	motor[RB]=0;
}

/**
* Turns bot left a given amount of seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @params  seconds   amount of seconds to turn left
* @params	 x         speed of motors
*
*/
void turnLeftSeconds(float seconds, float x=118)
{
	//Since turn left, we want to set the right motors forward and the left motors backwards
	motor[LF] = -x;
	motor[LB] = -x;
	motor[RF] = x;
	motor[RB] = x;
	wait1Msec(seconds*1000); //Wait desired amount of time
	motor[RB]=0;
	motor[RF]=0;
	motor[LF]=0;
	motor[LB]=0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 LAUNCHER FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////////////////
/**
* Runs the launcher with a specific speed for a number of rotations
*
* @author Joshua Asari  josh.asari@gmail.com
*
* @params rotations			the amount of times the launcher will rotate
* @params speed 				the speed at which the motor turns
*/

void runLauncherSec(float seconds)
{
	motor[launcher1] = 118;
	motor[launcher2] = -118;
	wait10Msec(seconds * 100);
	motor[launcher1] = 0;
	motor[launcher2] = 0;
}

/**
* Launcher controls
*
* @author Joshua Asari josh.asari@gmail.com
*
*/
void launcherCont()
{
	if(vexRT[Btn8D] == 1)
		{
			flywheel = 0;
		}
	else if(vexRT[Btn7D] == 1)
		{
			flywheel = 1;
		}

	if(flywheel == 0)
		{
		if(vexRT[Btn6D] == 1)
		{
			motor[launcher1] = -118;
			motor[launcher2] = 118;
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[launcher1] = 118;
			motor[launcher2] = -118;
		}
		else
		{
			motor[launcher1] = 0;
			motor[launcher2] = 0;
		}
	}
	else if(flywheel == 1)
		{
		if(vexRT[Btn6D] == 1)
		{
			motor[flywheel1] = -118;
			motor[flywheel2] = 118;
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[flywheel1] = 118;
			motor[flywheel2] = -118;
		}
		else
		{
			motor[flywheel1] = 0;
			motor[flywheel2] = 0;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 INTAKE FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////////////////
/**
* Runs the launcher with a specific speed for a number of rotations
*
* @author Joshua Asari  josh.asari@gmail.com
*
* @params seconds		    amount of time the intake will run for
*/
void runIntake(float seconds)
{
	motor[intake1] = -118;
	motor[intake2] = -118;
	wait10Msec(seconds * 100);
	motor[intake1] = 0;
	motor[intake2] = 0;
}

/**
* Intake controls
*
* @author Joshua Asari josh.asari@gmail.com
*
*/
void intakeCont()
{
	if(vexRT[Btn6U] == 1)
	{
		motor[intake1] = -118;
		motor[intake2] = -118;
	}
	else if(vexRT[Btn5U] == 1)
	{
		motor[intake1] = 118;
		motor[intake2] = 118;
	}
	else
	{
		motor[intake1] = 0;
		motor[intake2] = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 LCD FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////////////////
/**
* Clears the lines of the LCD
*
* @author Joshua Asari  josh.asari@gmail.com
*/
void clearline()
{
	clearLCDLine(0);
	clearLCDLine(1);
}

/**
* Shows the battery voltage
*
* @author Joshua Asari  josh.asari@gmail.com
*/
void battery()
{
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
	displayNextLCDString(mainBattery);
	if(nLCDButtons == rightButton)
	{
		clearline();
		back(1,0,0);
	}
}

/**
* Test screen for LCD
*
* @author Joshua Asari  josh.asari@gmail.com
*/
void autonomousLCD()
{
	displayLCDString(0, 0, "Base");
	if(nLCDButtons == rightButton)
	{
		back(1,0,0);
	}
}

/**
* Home screen for LCD
*
* @author Joshua Asari  josh.asari@gmail.com
*/
void mainLCD()
{
	if(nLCDButtons == leftButton)
	{
		isAutonomous = 1;
		isMain = 0;
		clearline();
	}
	if(nLCDButtons == centerButton)
	{
		isBattery = 1;
		isMain = 0;
		clearline();
	}
	if(isMain == 1)
	{
		displayLCDString(0, 0, "Team 241Nautilus");
		displayLCDString(1, 0, "Version 1.1");
	}
	if(isMain == 0 && isBattery == 1)
	{
		while(isMain == 0 && isBattery == 1)
		{
			battery();
		}
	}
	if(isMain == 0 && isAutonomous == 1)
	{
		while(isMain == 0 && isAutonomous == 1)
		{
			autonomousLCD();
		}
	}
}

/**
* Goes back a selection
*
* @author Joshua Asari josh.asari@gmail.com
*
*/
void back(int a, int b,int c)
{
	if((a == 1) && (b == 0) && (c == 0))
	{
		clearline();
		isMain = 1;
		isBattery = 0;
		isAutonomous = 0;
		mainLCD();
	}
	else if((a == 0) && (b == 1) && (c == 0))
	{
		clearline();
		isMain = 0;
		isBattery = 1;
		isAutonomous = 0;
		mainLCD();
	}
	else if((a == 0) && (b == 0) && (c == 1))
	{
		clearline();
		isMain = 0;
		isBattery = 0;
		isAutonomous = 1;
		mainLCD();
	}
}
